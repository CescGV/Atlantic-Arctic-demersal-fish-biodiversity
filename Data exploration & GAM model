### 1. Library ### ####

library(tidyverse)
library(mgcv)
library(sjPlot) # plot_model()
library(AER) # dispersiontest()
library(MASS)
library(raster)
library(tidyverse)
library(gridExtra)

### 2. My functions ### ####

round_05 <- function(x) {
  if (round(x) > x) {round(x) - 0.5}
  else if (round(x) <= x) {round(x) + 0.5}
}
variance <- function(x){sum((x-mean(x))^2)/length(x)}
se <- function(x) {sqrt(variance(x))/sqrt(length(x))}

### 3. Exploratory analysis and some further cleaning ### ####

# The whole data analysis is done using two approaches. On the one hand, I analyse the raw data
# considering each trawling event as a singular sampling site, and look at the change of 
# species richness found per sampling event, with time and latitude. This way considers n = 26 025 sites
# From these, there is more than 1 swept area for some sites, because more than 1 event occurred in a year (this happens only in 45 sites) 
# Load data, unselect max_length and min_length, because they contain many NAs and not needed for the analysis

# On the other hand, if I group by 1x1 cells of longitude and latitude, the picture changes a little and 
# the models are better fit, but I lose information. Also, I lose points close to the coast, which are highly relevant. 

# The data frame with richness at each trawling will be called "richness_pure", with the sites being "sites_pure"

# The data frame with richness at 1x1 lat long cell will be called " richness_cells" with the sites being "sites_cells" 

# START #

## Data load and remove of useless columns with NAs, and 13 points very far from the rest. 

full_dataset = read_csv("data_filtered_seas.csv")
full_dataset = full_dataset %>% select(- Max_length, - Min_length) %>% filter(Longitude > -4.5)

# Swept area transformation to Km2 instead of m2, and exploration of effort distribution with time, and range 

full_dataset$swept_area = full_dataset$swept_area / 10000 
boxplot(swept_area ~ Year, data = full_dataset)
range(full_dataset$swept_area) # From 0.5 to 28.5 Km2

# Figure of the geographical distribution of the effort

pdf("data_across_sites.pdf", height = 20, width = 20)
ggplot(full_dataset, aes(x = Longitude, y = Latitude)) + geom_point() + facet_wrap(.~ Year)
dev.off()


richness = full_dataset %>% ungroup() %>% dplyr::select(valid_name, Longitude, Latitude, Year, swept_area, Bot_depth) %>% 
  distinct() %>% group_by(Longitude, Latitude, Year, swept_area, Bot_depth) %>% summarise(richness = n())

sites = full_dataset %>% ungroup() %>% select(Longitude, Latitude, Year) %>% distinct()

# I gather all the species found (Presence data) within each degree of Lat Long, 
# And I sum all the effort (swept area) from all the trawling events at each degree of long lat.
# I am not loosing any richness and effort data, only spatial resolution.
# However, I need two dataframes: One with species at each site, and one with effort at each site, and then merge()

original_CI = richness %>% group_by(Year) %>%
  summarise(lambda = mean(richness),
            n = n()) %>%
  mutate(lower_edge = lambda - 1.96 * sqrt(lambda / n),
         higher_edge = lambda + 1.96 * sqrt(lambda/n)) %>%
  print(n = 32)

cor.test(original_CI$lambda, original_CI$n) #
plot(original_CI$lambda, original_CI$n) 

# There is a correlation between number of cells per year (n), and species richness per cell (lambda).
# I do not have an explanation for this, but there should not be causality 
# between the number of species found at each cell, and the total number of cells per year. 

plot(table(sites$Year)) 
boxplot(swept_area ~ Year, richness, ylim = c(0,50)) # Less area from 2011 onwards

# This trend needs to be considered. First 10 years have less points in the whole area,
# but each point does not contain less trawling, neither less area! (Actually contains more area)
# Even if there is an overall decline in swept area, this would imply that our results would be exacerbated, 
# therefore we are staying on the conservative side of the interpretation. 

# Novel spatial organisation also deserves a plot per year

#pdf("data_across_sites_novel.pdf", height = 20, width = 20)
#ggplot(richness_cells, aes(x = Long_one, y = Lat_one)) + geom_point() + facet_wrap(.~ Year)
#dev.off()

# Here all the plots for data exploration

f = ggplot(sites, aes(x = Year)) + geom_bar() + xlab("Year") 
g = ggplot(richness, aes(x = as.factor(Year), y = swept_area)) + geom_boxplot(outlier.size = 0.1) + xlab("Year") + scale_x_discrete(breaks = seq(1990,2020, by = 5))
h = ggplot(richness, aes(x = as.factor(Year), y = Latitude)) + geom_boxplot(outlier.size = 0.1) + xlab("Year") + scale_x_discrete(breaks = seq(1990,2020, by = 5))
i = ggplot(richness, aes(x = as.factor(Year), y = Longitude)) + geom_boxplot(outlier.size = 0.1) + xlab("Year") + scale_x_discrete(breaks = seq(1990,2020, by = 5))

pdf("Data_exploration.pdf", height = 10, width = 10)
grid.arrange(f,g,h,i, ncol = 2)
dev.off()

write.csv(richness_cells, "richness_in_1x1_cells.csv", row.names = F)
write.csv(richness_pure, "richness_all_sites.csv", row.names = F)

# The data is now ready for exploratory statistical modelling. 
# Model how has richness changed at each trawling with time and latitude. 
# Poisson distribution family (richness --> Count data) and area (effort) 
# as an explanatory variable


### 4. MODELS ### #####

richness$ID = sample(1:nrow(richness)) # I may needed later

# Model selection 


mod1 = glm(richness ~ Year + offset(log(swept_area)), data = richness, family = poisson)
mod2 = glm(richness ~ Year + swept_area, data = richness, family = poisson)
mod3 = glm(richness ~ Year + swept_area + Latitude + Year:Latitude, data = richness, family = poisson)
mod4 = glm(richness ~ Year + log(swept_area) + Latitude, data = richness, family = poisson)
mod5 = glm(richness ~ Year + Latitude + offset(log(swept_area)), data = richness, family = poisson)


summary(mod1)
summary(mod2)
summary(mod3)
summary(mod4)
summary(mod5)

par(mfrow = c(2,2)); plot(mod1) # 
par(mfrow = c(2,2)); plot(mod2) # Pretty good model. It is better to include the swept area as an explanatory variable, not as an offset 
par(mfrow = c(2,2)); plot(mod3) # Pretty good model, thought the residuals vs leverage not perfect 
par(mfrow = c(2,2)); plot(mod4) # Pretty good model 
par(mfrow = c(2,2)); plot(mod5)

# I try to fit a gam model: 

# - Year could have a non linear effect to richness
# - Swept area should be ok with a logarithmic scale fit, but its not. 
# - However, a smooth term for latitude makes no biological sense
# - Though an interaction term between Year and Latitude with a small number of knots 
#   could help to see if annual change of richness changes between latitudes. 

mod6 =  gam(richness ~ s(swept_area) + s(Year, by = Latitude), data = richness, family = poisson)

summary(mod6)
par(mfrow = c(2,2)); gam.check(mod6, type = "pearson")
abline(1,1, col = "red")

mod7 =  gam(richness ~ s(Year, k = 5) + s(Year, by = Latitude) + Latitude + s(swept_area), data = richness, family = poisson)

summary(mod7)
par(mfrow = c(2,2)); gam.check(mod7, type = "pearson")
abline(1,1, col = "red")


mod8 =  gam(richness ~ s(Year, k = 4) + s(Year, by = Latitude, k = 3) + s(swept_area) + ti(Latitude, Longitude),
              data = richness,
              family = poisson)

summary(mod8)
par(mfrow = c(2,2)); gam.check(mod8, type = "pearson")
abline(1,1, col = "red")

cor.test(predict(mod8), richness$richness)

gam.fit(mod8)

mod9 =  gam(richness ~ s(Year, k = 4) + s(Year, by = Latitude, k = 3) + s(swept_area) + ti(Latitude, Longitude),
              data = richness,fit = T,
              family = poisson)

summary(mod9)
par(mfrow = c(2,2)); gam.check(mod9, type = "pearson")
abline(1,1, col = "red")

gam.fit(mod9)

mod10 =  gam(richness ~ s(Year, k = 4) + s(swept_area) + ti(Latitude, Longitude),
              data = richness,
              family = poisson) 

summary(mod10)
par(mfrow = c(2,2)); gam.check(mod10, type = "pearson")
abline(1,1, col = "red")

mod11 =  gam(richness ~ s(Year, k = 4) + ti(Latitude, Longitude),
              data = richness,
              family = poisson) 

summary(mod11)
par(mfrow = c(2,2)); gam.check(mod11, type = "pearson")
abline(1,1, col = "red")

cor.test(predict(mod1), richness$richness)
cor.test(predict(mod2), richness$richness)
cor.test(predict(mod3), richness$richness)
cor.test(predict(mod4), richness$richness)
cor.test(predict(mod5), richness$richness)
cor.test(predict(mod6), richness$richness) 
cor.test(predict(mod7), richness$richness) 
cor.test(predict(mod8), richness$richness) 
cor.test(predict(mod9), richness$richness)  # Best model in terms of correlation, but more complex and just slightly model
cor.test(predict(mod10), richness$richness) # Best model --> Model very similar to the previous one, but simpler 
cor.test(predict(mod11), richness$richness) # Interestingly, the removal of swept area does not affect the model so much

summary(mod1)
summary(mod2)
summary(mod3)
summary(mod4)
summary(mod5)
summary(mod6)
summary(mod7)
summary(mod8)
summary(mod9)
summary(mod10)
summary(mod11)

# mod7_p is the best model that I can get without data transformation and without including environmental data. 
# Year has a clear positive effect in species richness with time, which does not change much with Latitude. 

# I check for overdispersion 

deviance(mod10)/mod10$df.residual
dispersiontest(mod10) # Not overdispersed :) 

### 5. MODEL VISUALISATION ### ####
draw(mod10)

a = plot_model(mod10,type = "pred", 
               terms = c("Year"), show.data = T, dot.alpha = 0.05, dot.size = 0.3) +
  scale_colour_continuous() + ggtitle("Richness across time")

b = plot_model(mod10, type = "pred", 
               terms = c("swept_area"), show.data = T, dot.alpha = 0.05, dot.size = 0.3) +
  scale_colour_continuous() + ggtitle("Richness across temperature")

# Graph of richness changes across time and Latitude

pdf("gam_temp_year_richness.pdf", height = 3.5, width = 7)
plot_model(mod10,type = "pred", 
           terms = c("Year"), show.data = T, dot.alpha = 1, dot.size = 0.9)  +
  scale_colour_continuous() + ggtitle("Richness across time")

dev.off()


# Graph of response variables
pdf("predictors_gam_richness.pdf", height = 2.5, width = 8)

grid.arrange(a,b, ncol = 2)

dev.off()

